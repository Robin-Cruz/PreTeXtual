%YAML 1.2
---
# Copyright 2016 David W. Rosoff

# This file is part of MBXTools, a package for Sublime Text.

# MBXTools is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# MBXTools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with MBXTools.  If not, see <http://www.gnu.org/licenses/>.
name: Mathbook XML
file_extensions:
  - mbx
# first_line_match: '^<?xml version="1.0" encoding="UTF-8"?>\s*<!--\s*MBX\s*-->'
scope: text.xml.mbx
variables:
  # This is the full XML Name production, but should not be used where namespaces
  # are possible. Those locations should use a qualified_name.
  name: '[[:alpha:]:_][[:alnum:]:_.-]*'
  # This is the form that allows a namespace prefix (ns:) followed by a local
  # name. The captures are:
  #  1: namespace prefix name
  #  2: namespace prefix colon
  #  3: local tag name
  qualified_name: '(?:([[:alpha:]_][[:alnum:]_.-]*)(:))?([[:alpha:]_][[:alnum:]_.-]*)'
  subdivision: '(book|article|part|chapter|(?:sub)*section|exercises|references)(?=\s)'
  # rule out matching e.g. 'booktitle'
  subdivision_data: '((?:sub)title|introduction|conclusion)'
  list: '(ul|ol|dl)'
  list_item: '(li)'
  paragraphs: '(paragraphs)'
  p: '(p)'
  statement: '(statement)'
  proof: '(proof)'
  definition: '(definition)'
  theoremlike: '(theorem|corollary|lemma|algorithm|proposition|claim)'
  axiomlike: '(fact|conjecture|axiom|principle)'
  example: '(example)'
  list_example_like: '(list_example_like)'
  remark: '(remark)'
  blockquote: '(blockquote)'
  attribution: '(attribution)'
  contributors: '(contributors)'
  list-of: '(list-of)'
  solution-list: '(solution-list)'
  notation-list: '(notation-list)'
  prompt: '(prompt)'
  input: '(input)'
  output: '(output)'
  pre: '(pre)'
  sage: '(sage)'
  program: '(program)'
  console: '(console)'
  todo: '(todo)'
  notation: '(notation)'
  usage: '(usage)'
  caption: '(caption)'
  table: '(table)'
  table_subdivision: '(tabular|col|row|cell)'
  figure: '(figure)'
  listing: '(listing)'
  sidebyside: '(sidebyside)'
  poem: '(poem)'
  stanza: '(stanza)'
  tex_special_char: '(nbsp|ndash|mdash|ampersand|less|greater|ellipsis|hash|dollar|percent|circumflex|underscore|lbrace|rbrace|lbracket|rbracket|ldblbracket|rdblbracket|langle|rangle|tilde|backslash|asterisk|lq|rq|lsq|rsq|midpoint|swungdash|permille|pilcrow|section-mark|dimension|slash|solidus|ie|eg|etc|circa|tex|latex|trademark|registered|today|timeofday)'
  inline_markup: '(em|alert|q|sq|braces|brackets|dblbrackets|angles|term|foreign|abbr|acro|init|fn)'
  inline_markup_code: '(c)'
  booktitle: '(booktitle)'
  url: '(url)'
  xref: '(xref)'
  index: '(index)'
  index_subdivision: '(main|sub|see)'
  math_inline: '(m)'
  math_displayed: '(m[ed]n?)'
  math_row: '(mrow)'
  math_row_intertext: '(intertext)'
  exercises: '(exercise(?:s|group)?)'
  exercises_help: '(hint|answer|solution)'
  webwork: '(webwork)'
  pg-macros: '(pg-macros)'
  macro-file: '(macro-file)'
  setup: '(setup)'
  stage: '(stage)'
  var: '(var)'
  static: '(static)'
  set: '(set)'
  member: '(member)'
  pg-code: '(pg-code)'
  video: '(video)'
  image: '(image)'
  description: '(description)'
  latex-image-code: '(latex-image-code)'
  asymptote: '(asymptote)'
  sageplot: '(sageplot)'
  quantity: '(quantity)'
  mag: '(mag)'
  unit: '(unit)'
  per: '(per)'
  docinfo: '(docinfo)'
  brandlogo: '(brandlogo)'
  website: '(website)'
  initialism: '(initialism)'
  macros: '(macros)'
  latex-image-preamble: '(latex-image-preamble)'
  feedback: '(feedback)'
  rename: '(rename)'
  frontmatter: '(frontmatter)'
  titlepage: '(titlepage)'
  author: '(author)'
  editor: '(editor)'
  contributor: '(contributor)'
  personname: '(personname)'
  department: '(department)'
  institution: '(institution)'
  email: '(email)'
  credit: '(credit)'
  date: '(date)'
  colophon: '(colophon)'
  copyright: '(copyright)'
  year: '(year)'
  holder: '(holder)'
  minilicense: '(minilicense)'
  shortlicense: '(shortlicense)'
  biography: '(biography)'
  abstract: '(abstract)'
  dedication: '(dedication)'
  acknowledgement: '(acknowledgement)'
  foreword: '(foreword)'
  preface: '(preface)'
  backmatter: '(backmatter)'
  appendix: '(appendix)'
  index-part: '(index-part)'
  index-list: '(index-list)'
  references: '(references)'
  biblio: '(biblio)'
  ibid: '(ibid)'
  journal: '(journal)'
  volume: '(volume)'
  number: '(number)'
  note: '(note)'

contexts:
  main:
    - match: '(<)\s*(?:{{subdivision}})'
      captures: 
        1: punctuation.definition.tag.begin.xml
      push: mbx-subdivision
    # - match: '(<xref\s+ref)\s*(=)\s*"({{qualified_name}})"'
    - match: '(<)xref'
      captures:
        1: punctuation.definition.tag.begin.xml
      #   2: entity.other.attribute-name.reference.mbx
      #   3: punctuation.separator.key-value.xml
      #   4: entity.other.attribute-value.reference-target.mbx
      push: mbx-xref
    - match: '(<\?)\s*({{qualified_name}})'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.xml
      push:
        - meta_scope: meta.tag.preprocessor.xml
        - match: \?>
          scope: punctuation.definition.tag.end.xml
          pop: true
        - match: '\s+{{qualified_name}}'
          captures:
            1: entity.other.attribute-name.namespace.xml
            2: entity.other.attribute-name.xml punctuation.separator.namespace.xml
            3: entity.other.attribute-name.localname.xml
        - include: double-quoted-string
        - include: single-quoted-string
    - match: '(<!)(DOCTYPE)(?:\s+({{name}}))?'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.doctype.xml
        3: variable.documentroot.xml
      push:
        - meta_scope: meta.tag.sgml.doctype.xml
        - match: \s*(>)
          captures:
            1: punctuation.definition.tag.end.xml
          pop: true
        - include: internal-subset
    - match: '<!--'
      scope: punctuation.definition.comment.xml
      push:
        - meta_scope: comment.block.xml
        - match: '-->'
          pop: true
    - match: '(</?){{qualified_name}}'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.namespace.xml
        3: entity.name.tag.xml punctuation.separator.namespace.xml
        4: entity.name.tag.localname.xml
      push:
        - meta_scope: meta.tag.xml
        - match: /?>
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: tag-stuff
    - match: '(</?)([[:digit:].-][[:alnum:]:_.-]*)'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: invalid.illegal.bad-tag-name.xml
      push:
        - meta_scope: meta.tag.xml
        - match: /?>
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: tag-stuff
    - include: entity
    - match: '<!\[CDATA\['
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.unquoted.cdata.xml
        - match: ']]>'
          scope: punctuation.definition.string.end.xml
          pop: true
    - include: should-be-entity
    # - include: mbx-subdivision
  should-be-entity:
    - match: '&'
      scope: invalid.illegal.bad-ampersand.xml
    - match: '<'
      scope: invalid.illegal.missing-entity.xml
    - match: '>'
      scope: invalid.illegal.missing-entity.xml
  double-quoted-string:
    - match: '"'
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.quoted.double.xml
        - match: '"'
          scope: punctuation.definition.string.end.xml
          pop: true
        - include: entity
        - include: should-be-entity
  entity:
    - match: '(&)(?:{{name}}|#[0-9]+|#x\h+)(;)'
      scope: constant.character.entity.xml
      captures:
        1: punctuation.definition.constant.xml
        2: punctuation.definition.constant.xml
  internal-subset:
    - match: \[
      scope: punctuation.definition.constant.xml
      push:
        - meta_scope: meta.internalsubset.xml
        - match: \]
          pop: true
        - include: entity-decl
        - include: element-decl
        - include: attlist-decl
        - include: notation-decl
        - include: parameter-entity
  entity-decl:
    - match: '(<!)(ENTITY)\s+(%\s+)?({{name}})(\s+(?:SYSTEM|PUBLIC)\s+)?'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.entity.xml
        3: punctuation.definition.entity.xml
        4: variable.entity.xml
        5: keyword.entitytype.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: double-quoted-string
        - include: single-quoted-string
  element-decl:
    - match: '(<!)(ELEMENT)\s+({{name}})\s+'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.element.xml
        3: variable.element.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - match: '\b(EMPTY|ANY)\b'
          scope: constant.other.xml
        - include: element-parens
  element-parens:
    - match: \(
      scope: punctuation.definition.group.xml
      push:
        - match: (\))([*?+])?
          captures:
            1: punctuation.definition.group.xml
            2: keyword.operator.xml
          pop: true
        - match: '#PCDATA'
          scope: constant.other.xml
        - match: '[*?+]'
          scope: keyword.operator.xml
        - match: '[,|]'
          scope: punctuation.separator.xml
        - include: element-parens
  attlist-decl:
    - match: '(<!)(ATTLIST)\s+({{name}})\s+({{name}})'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.attlist.xml
        3: variable.element.xml
        4: variable.attribute-name.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: double-quoted-string
        - include: single-quoted-string
  notation-decl:
    - match: '(<!)(NOTATION)\s+({{name}})'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.notation.xml
        3: variable.notation.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: double-quoted-string
        - include: single-quoted-string
  parameter-entity:
    - match: '(%){{name}}(;)'
      scope: constant.character.parameter-entity.xml
      captures:
        1: punctuation.definition.constant.xml
        2: punctuation.definition.constant.xml
  single-quoted-string:
    - match: "'"
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.quoted.single.xml
        - match: "'"
          scope: punctuation.definition.string.end.xml
          pop: true
        - include: entity
        - include: should-be-entity
  tag-stuff:
    - match: '(?:\s+|^){{qualified_name}}\s*(=)'
      captures:
        1: entity.other.attribute-name.namespace.xml
        2: entity.other.attribute-name.xml punctuation.separator.namespace.xml
        3: entity.other.attribute-name.localname.xml
        4: punctuation.separator.key-value.xml
    # - include: mbx-xmlid
    - include: double-quoted-string
    - include: single-quoted-string
  mbx-subdivision:
    - meta_scope: tag.subdivision.xml.mbx entity.name.tag.localname.xml meta.tag.xml
    - match: '>'
      scope: punctuation.definition.tag.end.xml
      pop: true
    # - match: '(xml:id)\s*=\*"'
    #   captures:
    #     1: entity.other.attribute-name.xmlid.xml.mbx
    #   push: mbx-xmlid
    - include: tag-stuff
    - include: double-quoted-string
  mbx-xref:
    - meta_scope: tag.reference.internal.xml.mbx entity.name.tag.localname.xml meta.tag.xml
    - match: '/>'
      scope: punctuation.definition.tag.end.xml
      pop: true
    - include: double-quoted-string
    - include: tag-stuff
    # - match: '"'
    #   push: double-quoted-string
    #   pop: true
  # mbx-xmlid:
  #   - meta_scope: 
  #   - match: '"'
  #     pop: true
  #   - 